---
layout: post
title: 추상클래스와 인터페이스
date: 2022-05-08 00:00:00+0900
category: Java
published: true
---
# [추상 클래스]
자바는 객체지향언어이기때문에 상속개념이 존재한다.  
그렇기때문에 클래스는 다른 클래스를 상속받아서 사용할 수 있다.  
이때 클래스는 **실체 클래스**와 **추상클래스**로 구분이 될 수 있는데, 실체 클래스는 객체를 직접 생성할 수 있는 클래스를 말하고, 추상 클래스는 객체를 직접 생성하지 못한다.  
추상 클래스는 보통 실체 클래스의 공통되는 필드와 메소드를 추출해서 만들게 된다. '추상'이라는 단어가 주는 의미처럼 실체들의 공통되는 특성을 가지고 있는 추상적인 클래스 이기 때문이다.  
프로그램 설계자 입장에서는 이 추상클래스를 이용해서 다수의 개발자들이 꼭 구현해야 하는 기능을 표현할 수 있는 등 그 쓰임새는 다양하다.  
실제객체를 바로 만들 수 없기때문에(new 연산자를 사용한 인스턴스 생성 불가능) 실체클래스에서 추상클래스를 상속받아서 생성해야 한다.

<br>
```java
class tiger extends Animal{...}
//Animal이 동물들의 공통된 점을 갖고있는 추상클래스일때 실제객체 tiger는 extends로 상속받게됨.
```  

### 추상 클래스 선언 
추상 클래스를 선언할 때에는 클래스 선언에 abstract키워드를 붙임. 
```java
public abstract class 클래스
{
    //필드
    //생성자
    //메소드
    [public | protected] abstract 리턴타입 메소드명(매개변수,...); //추상메소드 형식
}
```   
new연산자로 직접 생성자를 호출할 수는 없지만 자식객체가 생성될 때 super(...)를 호출해서 추상클래스 객체를 생성하므로 추상 클래스도 생성자가 있어야한다. 만약 없을경우 기본 생성자 생성됨.   
이때 알아두면 좋은 점이 있다.  
1. 추상 메소드가 하나도 없어도 abstract로 선언한 클래스도 추상 클래스이다.  
2. 추상 메소드를 하나라도 포함하는 클래스는 반드시 abstract로 선언되어야 한다.  
3. 추상 메소드는 선언부만 작성하고 구현부는 작성하지 않은 것이다. 

--- 

# [인터페이스]

### 인터페이스란?  
객체의 사용 방법을 정의한 타입. 개발 코드가 인터페이스의 메소드를 호출하면 인터페이스는 객체의 메소드를 호출시킴.  
그렇기 때문에 객체의 내부 구조를 알 필요가 없고 인터페이스의 메소드만 알고 있으면 된다. 인터페이스는 객체로 생성할 수 없기때문에 생성자를 가질 수 없다.  
형식은 아래와 같다.  
```java
[public] interface 인터페이스명 {...}
```
클래스는 필드,생성자,메소드를 구성 멤버로 가지는데 비해, 인터페이스는 상수와 메소드만을 구성 멤버로 가진다.  
```java
interface 인터페이스명
{
    //상수
    타입 상수명 = 값;
    //추상 메소드
    타입 메소드명(매개변수,...);
    //디폴트 메소드(자바8부터)    인터페이스에서 선언되지만 사실은 구현객체가 가지고 있는 인스턴스 메소드라고 생각해야함.
    default 타입 매소드명(매개변수,...) {...}
    //정적 메소드(자바8부터)    디폴트 메소드와 달리 객체가 없어도 인터페이스만으로 호출이 가능.
    static 타입 메소드명(매개변수) {...} 
}
```

**상수 필드**  
```java
[public static final] 타입 상수명 = 값; //public,static,final 은 생략하더라도 자동으로 컴파일 과정에서 생성됨.
```  
대문자로 상수를 작성하는것이 보통임. 다른 단어로 구성되어 있을경우 _사용.  
<br>
**추상 메소드**  
```java
[public abstract] 리턴타입 메소드명(매개변수, ...);
```  
인터페이스에 선언된 추상 메소드는 모두 public abstract의 특성을 갖기 때문에 public abstract를 생략하더라도 자동적으로 컴파일과정에서 붙게 됨.   
<br>
**디폴트 메소드**  
```java
[public] default 리턴타입 메소드명(매개변수,...){...}
```  
public을 생략해도 자동으로 붙게 됨.  
<br>
**정적 메소드**  
```java
[public] static 리턴타입 메소드명(매개변수,...) {...}
```  
public을 생략하더라도 자동적으로 컴파일 과정에서 붙음.  

<br>
<br>

### 구현 클래스  
```java
public class 구현클래스명 implements 인터페이스명
{
    //인터페이스에 선언된 추상 메소드의 실체 메소드 선언
}
```

<br>
### 익명 구현 객체  
구현 클래스를 만들어 사용하는것이 일반적이고 클래스를 재사용할 수 있기 때문에 편리하지만, 일회성의 구현 객체를 만들기 위해 소스 파일을 만들고 클래스를 선언하는 것은 비효율적이다.  
그래서 나온 개념이 익명 구현 객체이다.  
```java
인터페이스 변수 = new 인터페이스() 
{
    //인터페이스에 선언된 추상 메소드의 실체 메소드 선언
    중괄호 { }에는 인터페이스에 선언된 모든 추상 메소드들의 실체 메소드를 작성해야 함.  
    추가적으로 필드와 메소드를 선언할 수 있지만, 익명 객체 안에서만 사용할 수 있고 인터페이스 변수로 접근할 수 없다.  
}
```

---
<br>
## [자바는 클래스 다중상속이 안된다..그럼 이렇게라도..]
자바는 다중 상속을 지원하지 않기 때문에 인터페이스를 사용하여 다중 상속을 구현할수 있다. 
```java
public class 구현클래스명 extends 클래스명 implements 인터페이스A, 인터페이스B...
{
    //인터페이스 A에 선언된 추상 메소드의 실체 메소드 선언
    //인터페이스 B에 선언된 추상 메소드의 실체 메소드 선언
}  


위와 같은 형태를 사용하는데  
클래스 A와 클래스 B가 있을 때, IB라는 인터페이스를 만들어서 B의 메소드들과 
같은 형태의 추상메소드를 만들어 놓고 A를 상속하고 IB를 구현하는 클래스를 만들고
내부에 클래스 B를 선언하여 인터페이스들의 추상 메소드를의 몸통을 채울 경우
다중 상속과 같은 효과를 가진다.

public class TVCR extends Tv implements IVCR {

   VCR vcr = new VCR();
   public void play() {
      vcr.play();
   }
   public void stop(){
      vcr.stop();
   }
   public void reset() {
      vcr.reset();
   }

   ....
}
```  

---
<br>
## [하지만 인터페이스의 다중상속은 가능!]
```java
public interface 하위인터페이스 extends 상위인터페이스1,상위인터페이스2,...{...}
```  
하위 인터페이스를 구현하는 클래스는 하위 인터페이스의 메소드뿐만 아니라 상위 인터페이스의 모든 추상 메소드에 대한 실체 메소드를 갖어야 한다.  
